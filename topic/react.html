<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React note | Web 实验室</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/front-end-lab/icons/logo.svg">
    <link rel="manifest" href="/front-end-lab/manifest.json">
    <link rel="apple-touch-icon" href="/front-end-lab/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/front-end-lab/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="Web 开发笔记与解决方案">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/front-end-lab/assets/css/0.styles.7c75eff0.css" as="style"><link rel="preload" href="/front-end-lab/assets/js/app.9b37fe81.js" as="script"><link rel="preload" href="/front-end-lab/assets/js/2.8da06e8a.js" as="script"><link rel="preload" href="/front-end-lab/assets/js/28.20440020.js" as="script"><link rel="preload" href="/front-end-lab/assets/js/6.c336eb54.js" as="script"><link rel="prefetch" href="/front-end-lab/assets/js/10.a1d05808.js"><link rel="prefetch" href="/front-end-lab/assets/js/11.519ba01b.js"><link rel="prefetch" href="/front-end-lab/assets/js/12.39cc6ca3.js"><link rel="prefetch" href="/front-end-lab/assets/js/13.e91e7728.js"><link rel="prefetch" href="/front-end-lab/assets/js/14.8e94d4eb.js"><link rel="prefetch" href="/front-end-lab/assets/js/15.c4ac5dbd.js"><link rel="prefetch" href="/front-end-lab/assets/js/16.04d41f16.js"><link rel="prefetch" href="/front-end-lab/assets/js/17.d0d5757c.js"><link rel="prefetch" href="/front-end-lab/assets/js/18.9fe6a229.js"><link rel="prefetch" href="/front-end-lab/assets/js/19.e8491ae9.js"><link rel="prefetch" href="/front-end-lab/assets/js/20.2c725af9.js"><link rel="prefetch" href="/front-end-lab/assets/js/21.10e87515.js"><link rel="prefetch" href="/front-end-lab/assets/js/22.1932e21c.js"><link rel="prefetch" href="/front-end-lab/assets/js/23.845a8511.js"><link rel="prefetch" href="/front-end-lab/assets/js/24.8949837b.js"><link rel="prefetch" href="/front-end-lab/assets/js/25.7e8eb8e0.js"><link rel="prefetch" href="/front-end-lab/assets/js/26.922bfb58.js"><link rel="prefetch" href="/front-end-lab/assets/js/27.675c89be.js"><link rel="prefetch" href="/front-end-lab/assets/js/29.73e05d8e.js"><link rel="prefetch" href="/front-end-lab/assets/js/3.fbcf91a6.js"><link rel="prefetch" href="/front-end-lab/assets/js/30.9771b58a.js"><link rel="prefetch" href="/front-end-lab/assets/js/31.6755a233.js"><link rel="prefetch" href="/front-end-lab/assets/js/4.050bc6fc.js"><link rel="prefetch" href="/front-end-lab/assets/js/5.5ee46dd2.js"><link rel="prefetch" href="/front-end-lab/assets/js/7.94539ea5.js"><link rel="prefetch" href="/front-end-lab/assets/js/8.49ac6693.js"><link rel="prefetch" href="/front-end-lab/assets/js/9.f8be94ac.js">
    <link rel="stylesheet" href="/front-end-lab/assets/css/0.styles.7c75eff0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end-lab/" class="home-link router-link-active"><!----> <span class="site-name">Web 实验室</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-lab/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/front-end-lab/javascript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/front-end-lab/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/front-end-lab/REGEXP/" class="nav-link">
  REGEXP
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          开发
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/typescript/" class="nav-link">
  TypeScript
</a></li></ul></li><li class="dropdown-item"><h4>
          笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/topic/2020.html" class="nav-link">
  topic
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/operations/" class="nav-link">
  运维笔记
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/mobile/" class="nav-link">
  移动端开发解决方案
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/further/" class="nav-link">
  扩展阅读
</a></li><li class="dropdown-subitem"><a href="https://anran758.github.io/blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://anran758.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Web 展示页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <a href="https://github.com/anran758/front-end-lab" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-lab/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/front-end-lab/javascript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/front-end-lab/git/" class="nav-link">
  Git
</a></div><div class="nav-item"><a href="/front-end-lab/REGEXP/" class="nav-link">
  REGEXP
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          开发
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/typescript/" class="nav-link">
  TypeScript
</a></li></ul></li><li class="dropdown-item"><h4>
          笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/topic/2020.html" class="nav-link">
  topic
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/operations/" class="nav-link">
  运维笔记
</a></li><li class="dropdown-subitem"><a href="/front-end-lab/mobile/" class="nav-link">
  移动端开发解决方案
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front-end-lab/further/" class="nav-link">
  扩展阅读
</a></li><li class="dropdown-subitem"><a href="https://anran758.github.io/blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://anran758.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Web 展示页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <a href="https://github.com/anran758/front-end-lab" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/front-end-lab/topic/2020.html" class="sidebar-link">2020</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#html" class="sidebar-link">html</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#css" class="sidebar-link">css</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#综合" class="sidebar-link">综合</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#优化类" class="sidebar-link">优化类</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#解决方案" class="sidebar-link">解决方案</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#http" class="sidebar-link">HTTP</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#运维相关" class="sidebar-link">运维相关</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/2020.html#其他" class="sidebar-link">其他</a></li></ul></li><li><a href="/front-end-lab/topic/react.html" aria-current="page" class="active sidebar-link">React note</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/react.html#react" class="sidebar-link">React</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/react.html#redux" class="sidebar-link">Redux</a></li></ul></li><li><a href="/front-end-lab/topic/vue.html" class="sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/vue.html#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/vue.html#vue-使用" class="sidebar-link">vue 使用</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/vue.html#vue-原理" class="sidebar-link">vue 原理</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/vue.html#vue-的双向绑定原理是什么" class="sidebar-link">vue 的双向绑定原理是什么？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/vue.html#vue-router" class="sidebar-link">vue-router</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/vue.html#vuex" class="sidebar-link">vuex</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/vue.html#vue-性能优化" class="sidebar-link">vue 性能优化</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/vue.html#vue-与-react-的区别" class="sidebar-link">Vue 与 React 的区别</a></li></ul></li><li><a href="/front-end-lab/topic/webpack.html" class="sidebar-link">webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#为什么要使用-webpack-bundle工具" class="sidebar-link">为什么要使用 webpack/bundle工具？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#module、chunk、bundle-分别是什么" class="sidebar-link">module、chunk、bundle 分别是什么？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#loader-和-plugin-有什么区别-有自己实现过吗" class="sidebar-link">loader 和 plugin 有什么区别？有自己实现过吗？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#除了做基础脚手架外-还用来做过什么" class="sidebar-link">除了做基础脚手架外，还用来做过什么?</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#webpack-实现懒加载" class="sidebar-link">webpack 实现懒加载</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#webpack-优化项" class="sidebar-link">webpack 优化项</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#babel-runtime-和-babel-polyfill" class="sidebar-link">babel-runtime 和 babel-polyfill</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#什么是-tree-shaking" class="sidebar-link">什么是 Tree-Shaking</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#rollup-和-webpack-有什么区别" class="sidebar-link">rollup 和 webpack 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#esmodule-和-commonjs-有什么区别" class="sidebar-link">ESModule 和 commonJS 有什么区别</a></li><li class="sidebar-sub-header"><a href="/front-end-lab/topic/webpack.html#为什么要搭建脚手架-脚手架有什么用" class="sidebar-link">为什么要搭建脚手架，脚手架有什么用？</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-note"><a href="#react-note" class="header-anchor">#</a> React note</h1> <p><strong>目录</strong></p> <p></p><div class="table-of-contents"><ul><li><a href="#react">React</a><ul><li><a href="#react-是单向数据流还是双向数据流-它还有其他特点吗">React 是单向数据流还是双向数据流？它还有其他特点吗？</a></li><li><a href="#react-通过什么方式来更新数据">React 通过什么方式来更新数据</a></li><li><a href="#react-不能直接修改-state-吗">React 不能直接修改 State 吗？</a></li><li><a href="#setstate-是同步还是异步的">setState 是同步还是异步的？</a></li><li><a href="#函数组件是什么-与类组件有什么区别">函数组件是什么？与类组件有什么区别？</a></li><li><a href="#受控组件与非受控组件的区别">受控组件与非受控组件的区别</a></li><li><a href="#react中的合成事件是什么">React中的合成事件是什么？</a></li><li><a href="#为什么浏览器无法读取jsx">为什么浏览器无法读取JSX？</a></li><li><a href="#react-生命周期">React 生命周期</a></li><li><a href="#react-组件通信">React 组件通信</a></li><li><a href="#react-context-怎么使用">React.Context 怎么使用</a></li><li><a href="#react-怎么做代码复用">React 怎么做代码复用</a></li><li><a href="#高阶函数、高阶组件是什么">高阶函数、高阶组件是什么？</a></li><li><a href="#渲染列表为啥要用-key">渲染列表为啥要用 key？</a></li><li><a href="#虚拟-dom-是如何提升性能的">虚拟 dom 是如何提升性能的</a></li><li><a href="#可以描述一下-react-diffing-算法吗">可以描述一下 React Diffing 算法吗？</a></li><li><a href="#react-性能优化">React 性能优化</a></li><li><a href="#父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免">父组件在执行 render 时会不会触发子组件的 render 事件？如果会该怎么避免？</a></li><li><a href="#异步组件怎么使用">异步组件怎么使用？</a></li><li><a href="#jsx-是如何编译为-js-代码的">JSX 是如何编译为 js 代码的？</a></li><li><a href="#hooks-相比-class-的优点">Hooks 相比 class 的优点</a></li><li><a href="#hooks-的使用">Hooks 的使用</a></li><li><a href="#自定义-hook-怎么使用">自定义 Hook 怎么使用</a></li><li><a href="#hook-使用约束">Hook 使用约束</a></li><li><a href="#hooks-怎么实现-class-组件的功能">Hooks 怎么实现 class 组件的功能</a></li><li><a href="#有了解过-portals-吗">有了解过 Portals 吗?</a></li><li><a href="#什么是-react-fiber">什么是 React Fiber?</a></li><li><a href="#怎么对组件的参数做类型约束呢">怎么对组件的参数做类型约束呢?</a></li><li><a href="#组件设计原则">组件设计原则</a></li></ul></li><li><a href="#redux">Redux</a><ul><li><a href="#什么场景会考虑使用状态管理器">什么场景会考虑使用状态管理器</a></li><li><a href="#redux是什么-它遵循什么原则吗">redux是什么? 它遵循什么原则吗?</a></li><li><a href="#描述-redux-单向数据流">描述 redux 单向数据流</a></li></ul></li></ul></div><p></p> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <h3 id="react-是单向数据流还是双向数据流-它还有其他特点吗"><a href="#react-是单向数据流还是双向数据流-它还有其他特点吗" class="header-anchor">#</a> React 是单向数据流还是双向数据流？它还有其他特点吗？</h3> <ul><li>React 是单向数据流，数据是从上向下流</li> <li>声明式编写 UI</li> <li>组件化开发</li></ul> <h3 id="react-通过什么方式来更新数据"><a href="#react-通过什么方式来更新数据" class="header-anchor">#</a> React 通过什么方式来更新数据</h3> <p>React 是通过 <code>setState</code> 来更新数据的。调用多个 <code>setState</code> 不会立即更新数据，而是批量延迟更新后再将数据合并。</p> <p>除了 <code>setState</code> 外还可以使用 <code>forceUpdate</code> 跳过当前组件的 <code>shouldComponentUpdate</code> 对比，强制触发组件渲染(避免使用该方式)。</p> <h3 id="react-不能直接修改-state-吗"><a href="#react-不能直接修改-state-吗" class="header-anchor">#</a> React 不能直接修改 State 吗？</h3> <ol><li>直接修改 state 不会触发组件的渲染。</li> <li>若直接修改 state 引用的值，在实际使用时会导致错误的值出现</li> <li>修改后的 state 可能会被后续调用的 <code>setState</code> 覆盖</li></ol> <h3 id="setstate-是同步还是异步的"><a href="#setstate-是同步还是异步的" class="header-anchor">#</a> setState 是同步还是异步的？</h3> <p>出于性能的考虑，可能会把多个 <code>setState</code> 合并成一个调用。</p> <p>在 React 控制的生命周期、React 封装的事件处理器中直接使用是异步的(命中 <code>batchUpdate</code> 机制，<code>isBatchingUpdate</code> 的标志位为 <code>true</code>)。比如 React中注册的 <code>onClick</code> 事件或是 <code>componentDidMount</code> 中直接使用都是异步的。</p> <p>可以给 <code>setState</code> 第二个参数传递一个函数，该函数是<strong>数据更新后会触发的回调函数</strong>。在该函数中可以拿到更新后最新的值。</p> <p>在 React 控制外中使用 <code>setState</code> 是同步的，比如在  <code>setTimeout</code>, 或者是原生的事件监听器中使用都是同步的。</p> <h3 id="函数组件是什么-与类组件有什么区别"><a href="#函数组件是什么-与类组件有什么区别" class="header-anchor">#</a> 函数组件是什么？与类组件有什么区别？</h3> <p>函数组件本质上是一个纯函数，它接受 props 属性，最后返回 JSX。</p> <p>与类组件的差别在于: 它没有实例、不能通过 <code>extends</code> 继承于其他方法、也没有生命周期和 <code>state</code>(但可以引入 <code>Hooks</code> 来处理没有生命周期和 <code>state</code> 的问题)。</p> <h3 id="受控组件与非受控组件的区别"><a href="#受控组件与非受控组件的区别" class="header-anchor">#</a> 受控组件与非受控组件的区别</h3> <p>受控组件主要是指表单的值受到 <code>state</code> 的控制，它需要自行监听 <code>onChange</code> 事件来更新 <code>state</code>。</p> <p>由于受控组件每次都要编写事件处理器才能更新 <code>state</code> 数据、可能会有点麻烦，React 提供另一种代替方案是<strong>非受控组件</strong>。</p> <p>非受控组件将<strong>真实数据储存在 DOM 节点</strong>中,它可以为表单项设置默认值，不需要手动更新数据。当需要用到表单数据时再通过 <code>ref</code> 从 DOM 节点中取出数据即可。</p> <p><strong>注意: 多数情况下React 推荐编写受控组件。</strong></p> <p>扩展资料: <a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/" target="_blank" rel="noopener noreferrer">受控和非受控制使用场景的选择<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="react中的合成事件是什么"><a href="#react中的合成事件是什么" class="header-anchor">#</a> React中的合成事件是什么？</h3> <p>合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。</p> <h3 id="为什么浏览器无法读取jsx"><a href="#为什么浏览器无法读取jsx" class="header-anchor">#</a> 为什么浏览器无法读取JSX？</h3> <p>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。</p> <h3 id="react-生命周期"><a href="#react-生命周期" class="header-anchor">#</a> React 生命周期</h3> <p>针对 React 生命周期中函数的调用顺序，笔者写了一个简易的 Demo 用于演示: <a href="https://codesandbox.io/s/react-lifecycle-forked-2dvdg?file=/src/Parent.jsx" target="_blank" rel="noopener noreferrer">React 父子组件生命周期示例<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>React 组件挂载阶段</strong>先后会触发 <code>constuctor</code>、<code>static getDerivedStateFromProps</code>、<code>render</code>、<code>componentDidMount</code> 函数。若 <code>render</code> 函数内还有子组件存在的话，则会进一步递归:</p> <div class="language-log extra-class"><pre class="language-text"><code>[Parent]: constuctor
[Parent]: static getDerivedStateFromProps
[Parent]: render
[Children]: constuctor
[Children]: static getDerivedStateFromProps
[Children]: render
[Children]: componentDidMount
[Children]: 挂载阶段结束!
[Parent]: componentDidMount
[Parent]: 挂载阶段结束!
</code></pre></div><p><strong>React 组件更新阶段</strong>：主要是组件的 props 或 state 发生变化时触发。若组件内还有子组件，则子组件会判断是否也需要触发更新。默认情况下 <code>component</code> 组件是只要父组件发生了变化，子组件也会跟着变化。以下是更新父组件 <code>state</code> 数据时所触发的生命周期函数:</p> <div class="language-log extra-class"><pre class="language-text"><code>[Parent]: static getDerivedStateFromProps
[Parent]: shouldComponentUpdate
[Parent]: render
[Children]: static getDerivedStateFromProps
[Children]: shouldComponentUpdate
[Children]: render
[Children]: getSnapshotBeforeUpdate
[Parent]: getSnapshotBeforeUpdate
[Children]: componentDidUpdate
[Children]: 更新阶段结束!
[Parent]: componentDidUpdate
[Parent]: 更新阶段结束!
</code></pre></div><p><strong>React 组件销毁阶段</strong>：父组件先触发销毁前的函数，再逐层向下触发:</p> <div class="language-log extra-class"><pre class="language-text"><code>[Parent]: componentWillUnmount
[Parent]: 卸载阶段结束!
[Children]: componentWillUnmount
[Children]: 卸载阶段结束!
</code></pre></div><h3 id="react-组件通信"><a href="#react-组件通信" class="header-anchor">#</a> React 组件通信</h3> <ul><li>父组件通过 props 给子组件传参，子组件通过触发父组件提供的回调函数来给父组件传递数据</li> <li>React.Context</li> <li>自定义事件</li> <li>redux/mobx 之类的状态管理器</li></ul> <h3 id="react-context-怎么使用"><a href="#react-context-怎么使用" class="header-anchor">#</a> React.Context 怎么使用</h3> <p><code>Context</code> 可以共享对于组件树而言是全局的数据，比如全局主题、首选语言等。使用方式如下：</p> <ol><li><p><code>React.createContext</code> 函数用于生成 <code>Context</code> 对象。可以在创建时给 <code>Context</code> 设置默认值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">'light'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>Context</code> 对象中有一个 <code>Provider(提供者)</code> 组件，<code>Provider</code> 组件接受一个 <code>value</code> 属性用以将数据传递给消费组件。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemeContext.Provider</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dark<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>page</span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ThemeContext.Provider</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>获取 <code>Context</code> 提供的值可以通过 <code>contextType</code> 或者 <code>Consumer(消费者)</code> 组件中获取。<code>contextType</code> 只能用于类组件，并且只能挂载一个 <code>Context</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">;</span>
    <span class="token comment">/* 在组件挂载完成后，使用 MyContext 的值执行一些有副作用的操作 */</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">;</span>
    <span class="token comment">/* 基于 MyContext 的值进行渲染 */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
MyClass<span class="token punctuation">.</span>contextType <span class="token operator">=</span> MyContext<span class="token punctuation">;</span>
</code></pre></div><p>若想给组件挂载多个 <code>Context</code>, 或者在函数组件内使用 <code>Context</code> 可以使用 <code>Consumer</code> 组件:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemeContext.Consumer</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token punctuation">{</span><span class="token parameter">theme</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">UserContext.Consumer</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span><span class="token parameter">user</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ProfilePage</span></span> <span class="token attr-name">user</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span></span> <span class="token attr-name">theme</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>theme<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
      <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">UserContext.Consumer</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ThemeContext.Consumer</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ol> <p><code>Context</code> 通常适用于传递较为简单的数据信息，若数据太过复杂，还是需要引入状态管理(redux/mbox)。</p> <h3 id="react-怎么做代码复用"><a href="#react-怎么做代码复用" class="header-anchor">#</a> React 怎么做代码复用</h3> <ul><li><a href="https://react.html.cn/docs/render-props.html" target="_blank" rel="noopener noreferrer">Render Props<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>高阶组件 (HOC)</li> <li>自定义 Hooks</li> <li>Mixins (已被 React 废弃的方案)</li></ul> <p><code>Render props</code> 是一种在 React 组件之间共享代码的简单技术。具体的行为是:</p> <ol><li>子组件接收一个用于渲染指定视图的 <code>prop</code> 属性，该属性的类型是函数。</li> <li>父组件在组件内部定义该函数后，将函数的引入传给子组件</li> <li>子组件将组件内部 <code>state</code> 作为实参传给从外面传来的函数，并将函数的返回结果渲染在指定的视图区域。</li></ol> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 组件使用</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Mouse</span></span> <span class="token attr-name">render</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">x: </span><span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token plain-text">, y: </span><span class="token punctuation">{</span>y<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token comment">// 组件内部大致实现</span>
<span class="token keyword">class</span> <span class="token class-name">Mouse</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">头部信息</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">底部信息</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>准确来说 <code>Render props</code> 是一个用于告知组件需要渲染什么内容的函数属性。<code>props</code> 的命名可以由自己定义，比如用于在内容区域渲染的 prop 名可以叫 <code>render</code>，同时还可以再接收一个 <code>renderHead</code> 的 prop 用于渲染头部的信息。</p> <h3 id="高阶函数、高阶组件是什么"><a href="#高阶函数、高阶组件是什么" class="header-anchor">#</a> 高阶函数、高阶组件是什么？</h3> <p><strong>高阶函数</strong>就是<strong>接收其它函数作为参数</strong>的函数就称之为高阶函数，像数组的 <code>map</code> 、<code>sort</code>、<code>filter</code> 都是高阶函数。</p> <p><strong>高阶组件(Higher-order component, HOC)</strong> 是 React 用于复用组件逻辑的一种高级技巧。它具体的行为是：</p> <p>函数<strong>接收一个组件作为参数</strong>，在函数体内<strong>定义一个新组件</strong>，新组件内<strong>编写可复用的逻辑</strong>并应用到参数组件中。最后再将<strong>新组件作为函数的返回值</strong> return 出去。
<code>redux</code> 中的 <code>connect</code> 函数就是一个高阶组件。</p> <h3 id="渲染列表为啥要用-key"><a href="#渲染列表为啥要用-key" class="header-anchor">#</a> 渲染列表为啥要用 key？</h3> <p>渲染列表时，如果不给列表子项传 <code>key</code> 的话，React 将默认使用 <code>index</code> 作为 <code>key</code>，同时会在控制台发出警告。</p> <p><code>key</code> 在兄弟节点之间必须唯一，要避免使用数组下标 <code>index</code> 作为 <code>key</code>。因为使用数组下标作为 `key 时，若数组的顺序发生了改变，将会影响 Diffing 算法的效率。</p> <p>若列表的节点是组件的话，还可能会影响组件的 <code>state</code> 数据。因为组件实例是基于 <code>key</code> 来决定是否更新与复用。当顺序发生了变化，则 <code>key</code> 也会相应得被修改，从而导致子组件间的数据错乱。</p> <p>React 使用的 Diffing 算法是通过 <code>tag</code> 和 <code>key</code> 判断是否是同一个元素(<code>sameNode</code>)。使用唯一的 <code>key</code> 有助于 React 识别哪些元素发生改变，如节点添加或删除。这样有助于减少渲染次数，从而优化性能。</p> <p>如果数组中的数据没有唯一的 <code>key</code>，可以引入 <a href="https://www.npmjs.com/package/shortid" target="_blank" rel="noopener noreferrer">shortid<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 预先给数组中每项数据生成唯一的 <code>id</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> shortid <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'shortid'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">addId</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>data<span class="token punctuation">,</span>
    id<span class="token operator">:</span> shortid<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> newList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>addId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>若确定没有列表的顺序不会发生变化同时没有其他唯一的 <code>key</code> 来标识列表项时才能使用数组的下标。</p> <h3 id="虚拟-dom-是如何提升性能的"><a href="#虚拟-dom-是如何提升性能的" class="header-anchor">#</a> 虚拟 dom 是如何提升性能的</h3> <p>当组件触发更新时，虚拟 DOM 通过比对新旧 <code>state</code> 和 <code>props</code> 的变化以决定是否渲染 DOM 节点，从而减少渲染提升性能。因为修改真实 DOM 所耗费的性能远比操作 JavaScript 多几倍，因此使用虚拟 DOM 在渲染性能上会高效的多。</p> <h3 id="可以描述一下-react-diffing-算法吗"><a href="#可以描述一下-react-diffing-算法吗" class="header-anchor">#</a> 可以描述一下 React Diffing 算法吗？</h3> <p>Diffing 算法(Diffing Algorithm) 会先比较两个根元素的变化:</p> <ol><li>当<strong>节点类型变化</strong>时，将会卸载原有的树而建立新树。如父节点 <code>&lt;div&gt;</code> 标签被修改为 <code>&lt;section&gt;</code> 标签，则它们自身及 <code>children</code> 下的节点都会被重新渲染。</li> <li>当 <strong>DOM 节点类型相同</strong>时，保留相同的 DOM 节点，仅更新发生改变的属性。</li> <li>当<strong>组件类型相同时</strong>，组件更新时组件实例保持不变，React 将更新组件实例的 props, 并调用生命周期 <code>componentWillReceiveProps()</code> 和 <code>componentwillupdate()</code>，最后再调用 <code>render</code>。若 <code>render</code> 中还有子组件，将递归触发 Diff。</li> <li>当<strong>列表节点发生变化，列表项没有设置 key 时</strong>, 那么 Diffing 算法会逐个对比节点的变化。如果是尾部新增节点，那 Diff 算法会 Diff 到列表末尾，仅新增元素即可，不会有其他的性能损耗。若新增的数据不在数组的尾部而是在中间，那么 Diffing 算法比较到中间时判断出节点发生变化，将会丢弃后面所有节点并重新渲染。</li> <li>当<strong>列表节点发生变化，列表项有设置 key 时</strong>, React 可以通过 <code>key</code> 来匹配新旧节点间的对应关系，可以很快完成 Diff 并避免重复渲染的问题。</li></ol> <h3 id="react-性能优化"><a href="#react-性能优化" class="header-anchor">#</a> React 性能优化</h3> <ol><li><p><code>props/state</code> 新旧值的变化来决定是否渲染组件。</p> <p>React 可以通过 <code>shouldComponentUpdate</code>, <code>PureComponent</code>, <code>React.memo</code> 来对组件渲染进行性能优化。</p> <p><code>shouldComponentUpdate</code> 是 class 组件生命周期中的一个钩子，常用于 <code>component</code> 中。</p> <p>该钩子的返回值可以决定组件是否进行渲染，如果没有在组件内定义该钩子的逻辑，则默认返回 <code>true</code>, 这也就意味着 React 默认情况下是无条件渲染的。通常 <code>component</code> 组件可以通过该钩子对比数据，以决定组件是否该渲染，从而避免重复渲染的问题。</p> <blockquote><p>值得注意的是，即便在 <code>shouldComponentUpdate</code> 对新旧 props 使用深对比也不能破坏 React <strong>不可变值****不可变值</strong>原值。
因为直接改变 state 的数据再通过 setState 来更新数据，因为新旧数据的值是一致的(旧数据被修改)，也就不能触发渲染。</p></blockquote></li> <li><p>列表渲染时每项添加唯一的 <code>key</code>。</p></li> <li><p>定时器、DOM 事件等在组件销毁时一同销毁，从而避免内存泄露。</p></li> <li><p>代码分割，使用异步组件。</p></li> <li><p>Hooks 使用 <code>useMemo</code> 缓存上一次计算的结果，避免重复计算值。</p></li></ol> <h3 id="父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免"><a href="#父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免" class="header-anchor">#</a> 父组件在执行 render 时会不会触发子组件的 render 事件？如果会该怎么避免？</h3> <p>如果父组件渲染后，子组件接收的 props 也跟着发生了改变，那么默认情况下会触发子组件的渲染。</p> <p>若子组件接收的 props 没有发生改变，那就得判断子组件的状况。</p> <p>如果子组件是继承于 <code>component</code> 声明的组件，并且没有使用 <code>shouldComponentUpdate</code> 做避免重复渲染的处理，那么子组件会触发 render 事件。</p> <p>为了避免重复渲染，类组件可以使用 <code>shouldComponentUpdate</code> 来决定是否进行渲染。也可以将继承于 <code>component</code> 组件改为继承 <code>PureComponment</code>，该组件会浅对比 <code>Props</code> 是否进行改变，从而决定是否渲染组件。</p> <p>如果是函数组件，可以通过 <code>React.memo</code> 来对函数组件进行缓存。</p> <blockquote><p>问题本质上想问 React 性能优化的问题，可以参考上题答案。</p></blockquote> <h3 id="异步组件怎么使用"><a href="#异步组件怎么使用" class="header-anchor">#</a> 异步组件怎么使用？</h3> <ol><li><p>通过动态 <code>import()</code> 语法对组件代码进行分割。</p></li> <li><p>使用 <code>React.lazy</code> 函数，结合 <code>import()</code> 语法引入动态组件。在组件首次渲染时，会自动导入包含 <code>MyComponent</code> 的包。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./MyComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>在 <code>React.Suspense</code> 组件中渲染 <code>lazy</code> 组件，同时可以使用 <code>fallback</code> 做优雅降级(添加 <code>loading</code> 效果):</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Loading...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.Suspense</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>封装一个错误捕获组件(比如组件命名为 <code>MyErrorBoundary</code>)，组件内通过生命周期 <code>getDerivedStateFromError</code> 捕获错误信息。当异步组件加载失败时，将捕获到错误信息处理后给用户做错误提示功能。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyErrorBoundary</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Loading...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.Suspense</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">MyErrorBoundary</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ol> <h3 id="jsx-是如何编译为-js-代码的"><a href="#jsx-是如何编译为-js-代码的" class="header-anchor">#</a> JSX 是如何编译为 js 代码的？</h3> <p>在 React v17 之前，JSX 会被编译为 <code>React.createElement(component, props, ...children)</code> 函数，执行会返回 <code>vnode</code>，<code>vnode</code> 通过 <code>patch</code> 之类的方法渲染到页面。</p> <p>React v17 之后更新了 JSX 转换规则。新的 JSX 转换不会将 JSX 转换为 <code>React.createElement</code>，而是自动从 React 的 <code>package</code> 中引入新的入口函数(<code>react/jsx-runtime</code>)并调用。这意味着我们不用在每个组件文件中显式引入 <code>React</code>。</p> <h3 id="hooks-相比-class-的优点"><a href="#hooks-相比-class-的优点" class="header-anchor">#</a> Hooks 相比 class 的优点</h3> <p>类组件的不足:</p> <ul><li>状态逻辑复用难，缺少复用机制。渲染属性和高阶组件导致层级冗余</li> <li>复杂组件变得难以理解</li> <li>this 指向困扰</li></ul> <p>Hooks 的优点:</p> <ul><li>自定义 Hook 方便复用状态逻辑</li> <li>副作用的关注点分离</li> <li>函数组件没有 this 问题</li></ul> <p>Hooks 现有的不足:</p> <ul><li>不能完全代替 class 组件的生命周期，部分不常用的生命周期暂时没有实现</li> <li>useEffect 等 Hook 的运作方式带来了一定的学习成本，需要转换现有的编程思维</li></ul> <h3 id="hooks-的使用"><a href="#hooks-的使用" class="header-anchor">#</a> Hooks 的使用</h3> <blockquote><p>描述 Hooks 有哪些方法和大致用途</p></blockquote> <ol><li><p><code>useState</code>: 使函数组件支持设置 <code>state</code> 数据，可用于代替类组件的 <code>constructor</code> 函数。</p></li> <li><p><code>useEffect</code>: 使函数组件支持操作副作用的能力，可以模拟类组件 <code>componentDidMount</code> 的功能。同时还能监听数据变化，进而操作一系列诸如数据获取等副作用操作。 可以在 <code>useEffect</code> 的函数中返回一个函数做清除操作。这个清除操作时可选的:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第一个参数是函数</span>
<span class="token comment">// 第二个参数是函数内所依赖的外部变量数组。若没有外部依赖，则可以忽略第二个参数。</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">// useEffect 回调函数的返回值是函数的话，当组件卸载时会执行该函数</span>
   <span class="token comment">// 若没有需要清除的东西，则可以忽略这一步骤</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     document<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>handleClick<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>useContext</code>: 接收一个 <code>Context</code> 对象，并返回 <code>Context</code> 的当前值。相当于类组件的 <code>static contextType = MyContext</code>。</p></li> <li><p><code>useReducer</code> 是 <code>useState</code> 的代替方案，有点类似于 <code>redux</code> 的工作方式。它通过函数来操作 state，适合 state 逻辑较为复杂且包含多个子值，或是下一个 state 依赖于旧的 state 的场景。</p></li> <li><p><code>useMemo</code> 可以缓存变量的值，避免每次组件更新后都需要重复计算值。</p></li> <li><p><code>useCallbck</code> 用于缓存函数，避免函数被重复创建。它是 <code>useMemo</code> 的语法糖，<code>useCallback(fn, deps)</code> 相当于是 <code>useMemo(() =&gt; fn, deps)</code>。</p></li></ol> <h3 id="自定义-hook-怎么使用"><a href="#自定义-hook-怎么使用" class="header-anchor">#</a> 自定义 Hook 怎么使用</h3> <p>自定义 Hook 的命名规则是以 <code>use</code> 开头的函数，比如 <code>useLocalStorage</code> 就符合自定义 Hook 的命名规范。
使用自定义 Hook 的场景有很多，如表单处理、动画、订阅声明、定时器等等可复用的逻辑都能通过自定义 Hook 来抽象实现。</p> <p>在自定义 Hook 中，可以使用 Hooks 函数将可复用的逻辑和功能提取出来，并将内部的 <code>state</code> 或操作的方法从自定义 Hook 函数中返回出来。函数组件使用时就可以像调用普通函数一祥调用自定义 Hook 函数, 并将自定义 Hook 返回的 <code>state</code> 和操作方法通过解构保存到变量中。</p> <p>下面是 <a href="https://usehooks.com/useLocalStorage/" target="_blank" rel="noopener noreferrer">useLocalStorage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的实现，它将 state 同步到本地存储，以使其在页面刷新后保持不变。 用法与 useState 相似，不同之处在于我们传入了本地存储键，以便我们可以在页面加载时默认为该值，而不是指定的初始值。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token comment">// Usage</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Similar to useState but first arg is key to the value in local storage.</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useLocalStorage</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
        <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span>
        <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Enter your name<span class="token punctuation">&quot;</span></span>
        <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span>
        <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token function">setName</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span></span>
      <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Hook</span>
<span class="token keyword">function</span> <span class="token function">useLocalStorage</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> initialValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// State to store our value</span>
  <span class="token comment">// Pass initial state function to useState so logic is only executed once</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>storedValue<span class="token punctuation">,</span> setStoredValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// Get from local storage by key</span>
      <span class="token keyword">const</span> item <span class="token operator">=</span> window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// Parse stored json or if none return initialValue</span>
      <span class="token keyword">return</span> item <span class="token operator">?</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> initialValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// If error also return initialValue</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> initialValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Return a wrapped version of useState's setter function that ...</span>
  <span class="token comment">// ... persists the new value to localStorage.</span>
  <span class="token keyword">const</span> <span class="token function-variable function">setValue</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// Allow value to be a function so we have same API as useState</span>
      <span class="token keyword">const</span> valueToStore <span class="token operator">=</span>
        value <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">(</span>storedValue<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">;</span>
      <span class="token comment">// Save state</span>
      <span class="token function">setStoredValue</span><span class="token punctuation">(</span>valueToStore<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// Save to local storage</span>
      window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>valueToStore<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// A more advanced implementation would handle the error case</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>storedValue<span class="token punctuation">,</span> setValue<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意: 自定义 Hook 函数在定义时，也可以使用另一个自定义 Hook 函数。</strong></p> <h3 id="hook-使用约束"><a href="#hook-使用约束" class="header-anchor">#</a> Hook 使用约束</h3> <ol><li>只能在<strong>函数组件最顶层</strong>调用 Hook，不能在循环、条件判断或子函数中调用。</li> <li>只能在<strong>函数组件</strong>或者是<strong>自定义 Hook 函数</strong>中调用，普通的 js 函数不能使用。</li></ol> <h3 id="hooks-怎么实现-class-组件的功能"><a href="#hooks-怎么实现-class-组件的功能" class="header-anchor">#</a> Hooks 怎么实现 class 组件的功能</h3> <p>Hooks 没有生命周期，但可以通过 Hook 来模拟生命周期的功能。</p> <h4 id="constructor"><a href="#constructor" class="header-anchor">#</a> constructor</h4> <p>class 组件的构造函数一般是用于设置 state 或者给事件绑定 this 的。Hooks 中没有 this 指向的问题，而 state 可以通过 <code>useState</code>/<code>useReducer</code> 来实现。</p> <h4 id="getderivedstatefromprops"><a href="#getderivedstatefromprops" class="header-anchor">#</a> getDerivedStateFromProps</h4> <p><code>getDerivedStateFromProps</code> 用于在组件 props 变化时派生 <code>state</code>。可以通过 Hook 这样实现:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">ScrollView</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>row<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span>
    <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> row <span class="token operator">&gt;</span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Scrolling down: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="shouldcomponentupdate"><a href="#shouldcomponentupdate" class="header-anchor">#</a> shouldComponentUpdate</h4> <p><code>shouldComponentUpdate</code> 可以根据 <code>props</code>/<code>state</code> 的新旧值变化决定是否更新组件，在函数组件中可以使用 <code>React.memo</code> 达到同样的效果。</p> <p><code>React.memo</code> 默认只是浅比较 <code>props</code> 的变化，它的第一个参数是函数组件，第二个参数是可选的自定义比较函数，用于来比较新旧 <code>props</code>。</p> <h4 id="hooks-没有实现的生命周期钩子"><a href="#hooks-没有实现的生命周期钩子" class="header-anchor">#</a> Hooks 没有实现的生命周期钩子</h4> <ul><li>getSnapshotBeforeUpdate</li> <li>getDerivedStateFromError</li> <li>componentDidCatch</li></ul> <h4 id="如何强制更新-hook-组件"><a href="#如何强制更新-hook-组件" class="header-anchor">#</a> 如何强制更新 Hook 组件?</h4> <p>可以设置一个<strong>没有实际作用</strong>的 <code>state</code>，然后强制更新 <code>state</code> 的值触发渲染。</p> <h4 id="类实例成员变量如何映射到-hooks"><a href="#类实例成员变量如何映射到-hooks" class="header-anchor">#</a> 类实例成员变量如何映射到 Hooks?</h4> <p>使用 <code>useRef</code> 设置可变数据。</p> <h4 id="hook-中如何获取旧的-props-和-state"><a href="#hook-中如何获取旧的-props-和-state" class="header-anchor">#</a> Hook 中如何获取旧的 props 和 state</h4> <p>可以通过 <code>useRef</code> 来保存数据，因为渲染时不会覆盖掉 ref。</p> <h3 id="有了解过-portals-吗"><a href="#有了解过-portals-吗" class="header-anchor">#</a> 有了解过 Portals 吗?</h3> <p><code>Portals</code> 就像个传送门，它可以将子节点渲染到存在于父组件以外的 DOM 节点的方案。</p> <p>比如 <code>Dialog</code> 是一个全局组件，按照传统渲染组件的方式，<code>Dialog</code> 可能会受到其容器 css 的影响。因此可以使用 <code>Portals</code> 让组件在视觉上渲染到 <code>&lt;body&gt;</code> 中，使其样式不受 <code>overflow: hidden</code> 或 <code>z-index</code> 的影响。</p> <h3 id="什么是-react-fiber"><a href="#什么是-react-fiber" class="header-anchor">#</a> 什么是 React Fiber?</h3> <p>Fiber 是 React 16 中新的<strong>协调引擎或重新实现核心算法</strong>。它的主要目标是<strong>支持虚拟DOM的增量渲染</strong>。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。</p> <p>它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。</p> <h3 id="怎么对组件的参数做类型约束呢"><a href="#怎么对组件的参数做类型约束呢" class="header-anchor">#</a> 怎么对组件的参数做类型约束呢?</h3> <p>要对组件的参数做类型约束的话，可以引入 <code>prop-types</code> 来配置对应的 <code>propTypes</code> 属性。<br> <code>Flow</code> 和 <code>TypesScript</code> 则可以对整个应用做类型检查。</p> <h3 id="组件设计原则"><a href="#组件设计原则" class="header-anchor">#</a> 组件设计原则</h3> <ul><li>从功能上拆分组件</li> <li>组件功能原子化</li> <li>容器组件只管数据，UI 组件只管视图</li> <li>可复用、易用、直观</li> <li>组件库可以遵循 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles" target="_blank" rel="noopener noreferrer">ARIA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 规范</li></ul> <h2 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h2> <h3 id="什么场景会考虑使用状态管理器"><a href="#什么场景会考虑使用状态管理器" class="header-anchor">#</a> 什么场景会考虑使用状态管理器</h3> <p>从使用的角度:</p> <ol><li>用户的使用方式复杂</li> <li>不同身份的用户有不同的使用方式 (区分普通用户和 admin)</li> <li>多个用户之间可以协作</li> <li>与服务器大量交互，或使用了 websocket</li> <li>view 要从多个来源获取数据</li></ol> <p>从组件的角度来看:</p> <ol><li>某个组件的状态需要共享</li> <li>某个状态需要在任何地方都可以拿到</li> <li>一个组件需要改变全局状态</li> <li>一个组件需要改变另一个组件的状态</li></ol> <h3 id="redux是什么-它遵循什么原则吗"><a href="#redux是什么-它遵循什么原则吗" class="header-anchor">#</a> redux是什么? 它遵循什么原则吗?</h3> <p>Redux 是状态容器与数据流管理。它的三大原则是:</p> <ul><li>单一数据源</li> <li>状态不可变</li> <li>纯函数 (无副作用函数) 修改状态</li></ul> <h3 id="描述-redux-单向数据流"><a href="#描述-redux-单向数据流" class="header-anchor">#</a> 描述 redux 单向数据流</h3> <ol><li>Redux 内部维护一个 <code>state</code> 数据。这个 <code>state</code> 数据只能通过 <code>dispatch</code> 派生 <code>action</code> 事件才能修改。</li> <li>若 Redux 使用了中间件，先经过全部中间件处理</li> <li><code>dispatch</code> 触发事件后将 <code>action</code> 事件和当前的 <code>state</code> 数据传入给 <code>reducer</code>，由 <code>reducer</code> 对事件进行处理并返回更新后 <code>state</code> 数据。</li> <li><code>reducer</code> 的返回值将用于更新 <code>state</code> 数据</li> <li>如果需要获取 <code>state</code> 更新后的数据，可以调用 <code>subscribe</code> 方法，传递一个监听函数来订阅数据的变化。当数据更新后将会调用每个监听函数。</li> <li>将获取到的 <code>state</code> 数据渲染到视图中。</li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/anran758/front-end-lab/edit/master/docs/topic/react.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021/5/19 上午11:47:58</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front-end-lab/topic/2020.html" class="prev">
        2020
      </a></span> <span class="next"><a href="/front-end-lab/topic/vue.html">
        Vue
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/front-end-lab/assets/js/app.9b37fe81.js" defer></script><script src="/front-end-lab/assets/js/2.8da06e8a.js" defer></script><script src="/front-end-lab/assets/js/28.20440020.js" defer></script><script src="/front-end-lab/assets/js/6.c336eb54.js" defer></script>
  </body>
</html>
